pragma solidity ^0.4.12;
/**
* @file LibComplaint.sol
* @author yiyating
* @time 2016-12-27
* @desc 质押证券定义
*/


import "../utillib/LibInt.sol";
import "../utillib/LibString.sol";
import "../utillib/LibJson.sol";
import "../utillib/LibStack.sol";

library LibComplaint {
    using LibInt for *;
    using LibString for *;
    using LibJson for *;
    using LibComplaint for *;
    
    /**
    * @dev Contruction
    */
    struct Complaint {
        uint infoId;        //供需信息id
        address userId;     //投诉用户id
        uint   infoType;    //供需信息类别
        string userName;    //投诉用户姓名
        string reason;      //投诉原因
    }

    /**
    *@desc fromJson for Complaint
    *      Generated by juzhen SolidityStructTool automatically.
    *      Not to edit this code manually.
    */
    function fromJson(Complaint storage _self, string _json) internal returns(bool succ) {
        _self.reset();
        if(LibJson.push(_json) == 0) {
            return false;
        }

        if (!_json.isJson()) {
            LibJson.pop();
            return false;
        }

        _self.infoId = _json.jsonRead("infoId").toUint();
        _self.userId = _json.jsonRead("userId").toAddress();
        _self.infoType = _json.jsonRead("infoType").toUint();
        _self.userName = _json.jsonRead("userName");
        _self.reason = _json.jsonRead("reason");

        LibJson.pop();
        return true;
    }

    /**
    *@desc toJson for Complaint
    *      Generated by juzhen SolidityStructTool automatically.
    *      Not to edit this code manually.
    */
    function toJson(Complaint storage _self, string _infoDetail) internal constant returns (string _json) {
        uint len = 0;
        len = LibStack.push("{");
        len = LibStack.appendKeyValue("infoId", _self.infoId);
        len = LibStack.appendKeyValue("infoDetail", _infoDetail);
        len = LibStack.appendKeyValue("userId", _self.userId);
        len = LibStack.appendKeyValue("infoType", _self.infoType);
        len = LibStack.appendKeyValue("userName", _self.userName);
        len = LibStack.appendKeyValue("reason", _self.reason);
        len = LibStack.append("}");
        _json = LibStack.popex(len);
    }

    /**
    *@desc fromJsonArray for Complaint
    *      Generated by juzhen SolidityStructTool automatically.
    *      Not to edit this code manually.
    */
    function fromJsonArray(Complaint[] storage _self, string _json) internal returns(bool succ) {
        if(LibJson.push(_json) == 0) {
            return false;
        }
        _self.length = 0;

        if (!_json.isJson()){
            LibJson.pop();
            return false;
        }

        while (true) {
            string memory key = "[".concat(_self.length.toString(), "]");
            if (!_json.jsonKeyExists(key))
                break;

            _self.length++;
            _self[_self.length-1].fromJson(_json.jsonRead(key));
        }

        LibJson.pop();
        return true;
    }

    /**
    *@desc update for Complaint
    *      Generated by juzhen SolidityStructTool automatically.
    *      Not to edit this code manually.
    */
    function update(Complaint storage _self, string _json) internal returns(bool succ) {
        LibJson.push(_json);
        if (!_json.isJson()) {
            LibJson.pop();
            return false;
        }

        if (_json.jsonKeyExists("infoId"))
            _self.infoId = _json.jsonRead("infoId").toUint();
        if (_json.jsonKeyExists("userId"))
            _self.userId = _json.jsonRead("userId").toAddress();
        if (_json.jsonKeyExists("infoType"))
            _self.infoType = _json.jsonRead("infoType").toUint();
        if (_json.jsonKeyExists("userName"))
            _self.userName = _json.jsonRead("userName");
        if (_json.jsonKeyExists("reason"))
            _self.reason = _json.jsonRead("reason");

        LibJson.pop();
        return true;
    }

    /**
    *@desc reset for Complaint
    *      Generated by juzhen SolidityStructTool automatically.
    *      Not to edit this code manually.
    */
    function reset(Complaint storage _self) internal {
        delete _self.infoId;
        delete _self.userId;
        delete _self.infoType;
        delete _self.userName;
        delete _self.reason;
    }
}